@inject IJSRuntime JS
@implements IAsyncDisposable

<div @ref="_bpmnJsElement" style="height:100%;"></div>

@BpmnOverlays



@code
{
    ElementReference _bpmnJsElement;
    IJSObjectReference _bpmnJsModule;
    IJSObjectReference _bpmnJsInstance;

    [Parameter]
    public List<OverlayConfig> OverlayConfigs { get; set; } = new();

    [Parameter]
    public string BpmnXml { get; set; }

    bool _diagramLoaded;


    List<BpmnElement> _bpmnElements = new();

    [Parameter]
    public EventCallback<BpmnElement> OnElementSelection { get; set; }


    RenderFragment BpmnOverlays => __builder =>
    {
        if (_diagramLoaded)
        {
            foreach (var config in OverlayConfigs)
            {
                if (config.State == "INIT")
                {
                    <div @ref="@config.HtmlElementRef" @key="@config" style="display:none">
                        @config.OverlayRenderFragment(_bpmnElements.Single(element => element.InternalId == config.ElementId))
                    </div>
                }
            }
        }
    };


    DotNetObjectReference<BpmnViewer2> _dotNetJsRef;


    async Task RecenterDiagram()
    {
        await _bpmnJsModule.InvokeVoidAsync("recenterDiagram", _bpmnJsInstance);
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetJsRef = DotNetObjectReference.Create(this);

            _bpmnJsModule = await JS.InvokeAsync<IJSObjectReference>("import", "./_content/BpmnJs/js/bpmn/bpmn-modeler.interop.js");
            _bpmnJsInstance = await _bpmnJsModule.InvokeAsync<IJSObjectReference>("createBpmnJSInstance", _bpmnJsElement);

            await _bpmnJsInstance.InvokeVoidAsync("importXML", BpmnXml);

            var elementIds = await _bpmnJsModule.InvokeAsync<List<string>>("getAllElementPropertyIds", _bpmnJsInstance);

            elementIds.ForEach(id => { _bpmnElements.Add(new BpmnElement(_bpmnJsInstance, JS, id)); });

            if (OnElementSelection.HasDelegate)
            {
                //Setup callback for element selection
                await _bpmnJsModule.InvokeVoidAsync("setupElementSelectionListener", _bpmnJsInstance, _dotNetJsRef);
            }

            await RecenterDiagram(); //@TODO add support for recenter on page change

            _diagramLoaded = true;
            
            StateHasChanged(); // Required to ensure that second render occurs to load overlays (because overlays pass the BPMN elements as params to the render fragments)
        }
        if (!firstRender && _diagramLoaded)
        {
            await SetupOverlays();
        }
    }


    async Task SetupOverlays()
    {
        foreach (var overlayConfig in OverlayConfigs)
        {
    // Only setup overlays that do not have a overlayID (because they have not been created yet)
            if (overlayConfig.State == "INIT" && overlayConfig.OverlayId == null)
            {
                overlayConfig.OverlayId = await _bpmnJsModule.InvokeAsync<string>("addOverlay", overlayConfig, _bpmnJsInstance);
            }
        }
    }

    async Task RemoveOverlays(List<string> overlayIds)
    {
        await _bpmnJsModule.InvokeVoidAsync("removeOverlays", overlayIds, _bpmnJsInstance);
    }

    public async Task HideOverlays(IEnumerable<string> tags, string currentState = "INIT")
    {
        var overlays = OverlayConfigs .FindAll(i => i.Tags.Intersect(tags).Any() && i.State == currentState);

        if (overlays.Any())
        {
            // IDs are collected so we have a copy of the values to send to bpmnjs
            var ids = overlays.Select(i => i.OverlayId).ToList();

            // Needs to be a Task.run to ensure all changes occur before triggering the params change...
            await Task.Run(() => overlays.ForEach(i =>
            {
                i.State = "HIDE";
                i.OverlayId = null;
                i.HtmlElementRef = null;
            }));
            StateHasChanged(); // StateHasChanged is required for the UI to update and remove the un-needed elements
            await RemoveOverlays(ids); // Once the UI was updated to remove elements, we can trigger BpmnJS to remove the overlay which will remove the BPMNjs wrapping div.
        }
    }

    public async Task ShowOverlays(IEnumerable<string> tags, string currentState = "HIDE", string newState = "INIT")
    {
        var overlays = OverlayConfigs.FindAll(i => i.Tags.Intersect(tags).Any() && i.State == currentState);

        if (overlays.Any())
        {
            // This will trigger change detection and cause OnParams Set to trigger
            await Task.Run(() => overlays.ForEach(i => i.State = newState));
    
            //StateHasChanged is NOT required here because Blazor will trigger the update based on params change.
            // If you run StateHasChanged it will double create the overlay on the blazor side but only one will be sent to bpmnjs (race event?)
        }
    }


    [JSInvokable]
    public async Task ElementSelectedEvent(string elementId)
    {
        var element = elementId != null ? new BpmnElement(_bpmnJsInstance, JS, elementId) : null;
        await OnElementSelection.InvokeAsync(element);
    }


    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        await _bpmnJsInstance.InvokeVoidAsync("destroy"); // @TODO REVIEW
        await _bpmnJsInstance.DisposeAsync();
        await _bpmnJsModule.DisposeAsync();
    }

}