@inject IJSRuntime JS
@using System.Text.Json
@implements IAsyncDisposable

<div @ref="bpmnJsElement" style="height:100%;"></div>


<div style="display:none">
    @* @TODO rebuild this as a RenderTree builder *@
    @if (ApplyActivityIncidentCounts)
    {
        @foreach (KeyValuePair<string, int> entry in activityIncidentCounts)
        {
            <div @ref=activityIncidentRefs[entry.Key]>
                @if (activityIncidentCountDisplay != null)
                {
                    @activityIncidentCountDisplay(activityIncidentCounts[entry.Key])
                }
                else
                {
                    <div>@activityIncidentCounts[entry.Key]</div>
                }
            </div>
        }
    }

    
    
    @if (ApplyActiveActivityCounts)
    {
        @foreach (KeyValuePair<string, int> entry in activeActivityCounts)
        {
            <div @ref=activeActivityRefs[entry.Key]>
                @if (activeActivityCountDisplay != null)
                {
                    @activeActivityCountDisplay(activeActivityCounts[entry.Key])
                }
                else
                {
                    <div>@activeActivityCounts[entry.Key]</div>
                }
            </div>
        }
    }
    
    
    @if (applyCompletedActivityInstanceCounts)
    {
        @foreach (KeyValuePair<string, int> entry in completedActivityInstanceCounts)
        {
            <div @ref=completedActivityInstanceRefs[entry.Key]>
                @if (completedActivityInstanceCountDisplay != null)
                {
                    @completedActivityInstanceCountDisplay(completedActivityInstanceCounts[entry.Key])
                }
                else
                {
                    <div>@completedActivityInstanceCounts[entry.Key]</div>
                }
            </div>
        }
    }
    
    
    @if (applyWaitingExecutionCounts)
    {
        @foreach (KeyValuePair<string, int> entry in waitingExecutionCounts)
        {
            <div @ref=waitingExecutionCountsRefs[entry.Key]>
                @if (waitingExecutionCountDisplay != null)
                {
                    @waitingExecutionCountDisplay(waitingExecutionCounts[entry.Key])
                }
                else
                {
                    <div>@waitingExecutionCounts[entry.Key]</div>
                }
            </div>
        }
    }

</div>


@code
{
    public ElementReference bpmnJsElement;
    public IJSObjectReference bpmnJsModule;
    public IJSObjectReference bpmnJsInstance;

    [Parameter]
    public RenderFragment<int> activityIncidentCountDisplay { get; set; }

    [Parameter]
    public Dictionary<string, int> activityIncidentCounts { get; set; } = new();

    [Parameter]
    public bool ApplyActivityIncidentCounts { get; set; }

    Dictionary<string, ElementReference> activityIncidentRefs = new();



    [Parameter]
    public RenderFragment<int> activeActivityCountDisplay { get; set; }

    [Parameter]
    public Dictionary<string, int> activeActivityCounts { get; set; } = new();

    [Parameter]
    public bool ApplyActiveActivityCounts { get; set; }

    Dictionary<string, ElementReference> activeActivityRefs = new();



    [Parameter]
    public RenderFragment<int> completedActivityInstanceCountDisplay { get; set; }

    [Parameter]
    public Dictionary<string, int> completedActivityInstanceCounts { get; set; } = new();

    [Parameter]
    public bool applyCompletedActivityInstanceCounts { get; set; }

    [Parameter]
    public bool applyCompletedActivityMarker { get; set; }

    [Parameter]
    public string completedActivityMarkerConfig { get; set; }

    Dictionary<string, ElementReference> completedActivityInstanceRefs = new();



    [Parameter]
    public RenderFragment<int> waitingExecutionCountDisplay { get; set; }

    [Parameter]
    public Dictionary<string, int> waitingExecutionCounts { get; set; } = new();

    [Parameter]
    public bool applyWaitingExecutionCounts { get; set; }

    Dictionary<string, ElementReference> waitingExecutionCountsRefs = new();


    public IJSObjectReference heatmapJsInstance;

    [Parameter]
    public bool HeatmapVisible { get; set; }

    [Parameter]
    public EventCallback<bool> HeatmapVisibleChanged { get; set; }

    [Parameter]
    public string HeatmapProcessDefinitionKey { get; set; }


    [Parameter]
    public string bpmnXml { get; set; }


    [Parameter]
    public EventCallback<BpmnElement> OnElementSelection { get; set; }

    DotNetObjectReference<BpmnViewer> _dotNetJsRef;


    protected override void OnInitialized()
    {
        _dotNetJsRef = DotNetObjectReference.Create(this);
    }

    public async Task RecenterDiagram()
    {
        await bpmnJsModule.InvokeVoidAsync("recenterDiagram", bpmnJsInstance);
    }


    protected override async Task OnParametersSetAsync()
    {
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            bpmnJsModule = await JS.InvokeAsync<IJSObjectReference>("import", "./_content/BpmnJs/js/bpmn/bpmn-modeler.interop.js");
            bpmnJsInstance = await bpmnJsModule.InvokeAsync<IJSObjectReference>("createBpmnJSInstance", bpmnJsElement);

            await bpmnJsInstance.InvokeVoidAsync("importXML", bpmnXml);

            if (OnElementSelection.HasDelegate)
            {
                await bpmnJsModule.InvokeVoidAsync("setupElementSelectionListener", bpmnJsInstance, _dotNetJsRef);
            }

            var canvas = await bpmnJsInstance.InvokeAsync<IJSObjectReference>("get", "canvas");

            await canvas.InvokeVoidAsync("zoom", "fit-viewport", "auto");
            //@TODO add support for recenter on page change
        }
        if (bpmnJsInstance != null)
        {
            await SetupHeatmap();
            await SetupOverlays();
        }

    }



    public async Task SetupHeatmap()
    {
        if (HeatmapVisible)
        {
            var activities = completedActivityInstanceCounts.ToList();
            heatmapJsInstance = await bpmnJsModule.InvokeAsync<IJSObjectReference>("generateHeatmap", activities, bpmnJsInstance, bpmnJsElement, heatmapJsInstance, null);
        }
        else
        {
            if (heatmapJsInstance != null)
            {
                await bpmnJsModule.InvokeVoidAsync("destroyHeatmap", bpmnJsElement);
                heatmapJsInstance = null;
            }
        }
    }

    public async Task SetupOverlays()
    {
        var overlays = await bpmnJsInstance.InvokeAsync<IJSObjectReference>("get", "overlays");
        var canvas = await bpmnJsInstance.InvokeAsync<IJSObjectReference>("get", "canvas");

        if (ApplyActivityIncidentCounts)
        {
            foreach (var entry in activityIncidentRefs)
            {
                var id = await overlays.InvokeAsync<string>("add", entry.Key,
                    new
                    {
                        position = new
                        {
                            bottom = 16,
                            left = 0
                        },
                        html = entry.Value
                    });

            }
        }


        if (ApplyActiveActivityCounts)
        {
            foreach (var entry in activeActivityRefs)
            {
                var id = await overlays.InvokeAsync<string>("add", entry.Key,
                    new
                    {
                        position = new
                        {
                            bottom = 16,
                            right = 16
                        },
                        html = entry.Value
                    });
            }
        }

        if (applyCompletedActivityInstanceCounts)
        {
            foreach (var entry in completedActivityInstanceRefs)
            {
                var id = await overlays.InvokeAsync<string>("add", entry.Key,
                    new
                    {
                        position = new
                        {
                            top = -10,
                            right = 16
                        },
                        html = entry.Value
                    });
            }
        }


        if (applyCompletedActivityMarker)
        {
            if (completedActivityMarkerConfig != null)
            {
                foreach (var activityId in completedActivityInstanceCounts.Keys)
                {
                    await canvas.InvokeVoidAsync("addMarker", activityId, completedActivityMarkerConfig);
                }
            }
        }

        if (applyWaitingExecutionCounts)
        {
            foreach (var entry in waitingExecutionCountsRefs)
            {
                var id = await overlays.InvokeAsync<string>("add", entry.Key,
                    new
                    {
                        position = new
                        {
                            bottom = 38,
                            right = 8
                        },
                        html = entry.Value
                    });
            }
        }
    }


    [JSInvokable]
    public async Task ElementSelectedEvent(string elementId)
    {
        var element = elementId != null ? new BpmnElement(bpmnJsInstance, JS, elementId) : null;
        await OnElementSelection.InvokeAsync(element);
    }


    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        await bpmnJsInstance.DisposeAsync();
        await bpmnJsModule.DisposeAsync();

        if (heatmapJsInstance != null)
        {
            await heatmapJsInstance.DisposeAsync();
        }

    }

}